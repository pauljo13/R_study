___
# R Vector
벡터는 R의 통계 분석에서 가장 중요한 데이터 형식이다. 다른 범용의 프로그래밍 언어와는 다르게 R은 벡터 단위의 연산 및 조작을 지원함으로써 통계 데이터 분석에 매우 편리한 이점을 제공한다.

- 벡터는 동일 형식 데이터의 나열
	- 숫자 벡터는 숫자 데이터만 나열되고, 문자 벡터나 논리 벡터에는 각각 문자열과 논리값만이 나열된다.
- 벡터의 길이/크기
	- 벡터가 포함하고 있는 데이터의 개수를 벡터의 길이 또는 크기라고 한다.


### 숫자 벡터
##### c() 함수를 이용한 숫자 벡터 생성
c() 함수는 여러 가지 기능을 하지만 가장 중요한 기능은 두개 이상의 벡터를 인수로 받아 이를 연결(Concatenating)하여 새로운 벡터를 만든다.
```r
> y <- c(2, 4, 6, 8, 10)
> y
[1]  2  4  6  8 10

> x <- c(1,3,5,7,9.2) # 하나라도 실수값이 있으면 다른 값들도 실수로 표현된다.
> x
[1] 1.0 3.0 5.0 7.0 9.2

# 길이가 2 이상인 벡터 연결하여 새 벡터를 만들 수 있다.
> z <- c(x, y)
> z
 [1]  1.0  3.0  5.0  7.0  9.2  2.0  4.0  6.0  8.0 10.0

# 여러 주레 걸친 벡터가 출력
> w <- c(x,y,z)
> w
 [1]  1.0  3.0  5.0  7.0  9.2  2.0  4.0  6.0  8.0 10.0  1.0  3.0  5.0  7.0  9.2  2.0  4.0  6.0  8.0 10.0
```

##### 패턴을 이용한 숫자 벡터
```r
# n:m
## 숫자 n부터 시작하여 숫자 m까지 1씩 증가하거나 감소하는 수열
## 실수여도 무조건 1씩 증가하거나 감소한다.
> 1:10
 [1]  1  2  3  4  5  6  7  8  9 10
> 10 : 1
 [1] 10  9  8  7  6  5  4  3  2  1
> -4:8
 [1] -4 -3 -2 -1  0  1  2  3  4  5  6  7  8
> 0.7:8
[1] 0.7 1.7 2.7 3.7 4.7 5.7 6.7 7.7
> 2.3:-5
[1]  2.3  1.3  0.3 -0.7 -1.7 -2.7 -3.7 -4.7


# seq()
## 1씩 증가하거나 감소하는 수열 벡터뿐 아니라 좀 더 복잡한 벡터도 생성가능
seq(n,m) # n에서 m까지 1씩 증가하거나 감소한다.
seq(n,m, by=k) # n에서 m까지 k씩 만큼 증가하거나 감소한다.
seq(length=j, from=n, by=k) # n부터 시작하여 k씩 만큼 증가하여 j길이 만큼 수열 생성

> seq(5,15)
 [1]  5  6  7  8  9 10 11 12 13 14 15

> seq(5, 15, by = 2)
[1]  5  7  9 11 13 15

> seq(length = 10, form = -3, by = 0.5)
 [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5

> seq(length = 10, from = -3, by = 0.5)
 [1] -3.0 -2.5 -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5

## 1부터 어떤 벡터의 길이까지 일련번호를 생성할 때 seq() 함수를 이용하면 편리하다. seq()의 along인수에 벡터를 부여하면 1부터 그 벡터의 길이만큼 일련번호가 생성된다.
> y
[1]  2  4  6  8 10
> seq(along = y)
[1] 1 2 3 4 5


# rep()
## 어떤 벡터를 반복시켜서 새로운 벡터를 만들고 싶을 때는 rep()함수를 이용한다. 첫번째 인수에 반복할 벡터를, times 인수에 반복할 횟수를 부여한다.
> y = c(1:5, 0:-5)
> y
 [1]  1  2  3  4  5  0 -1 -2 -3 -4 -5
> rep(y, times = 2)
 [1]  1  2  3  4  5  0 -1 -2 -3 -4 -5  1  2  3  4  5  0 -1 -2 -3 -4 -5
> rep(1, times = 10)
 [1] 1 1 1 1 1 1 1 1 1 1
> rep(y, each = 2)
 [1]  1  1  2  2  3  3  4  4  5  5  0  0 -1 -1 -2 -2 -3 -3 -4 -4 -5 -5
 
```

### Numbers vector operation
##### Elementwise operation
R의 강점 중 하나가 벡터의 요소끼리 연산을 지원한다는 것이다. 이는 여타 언어에서는 볼 수 없는 점이다. 길이가 동일한 두 벡터에 더하기나 곱하기 연산 등을 수행하면, 같은 위치에 있는 요소끼리 해당 연산이 이루어진다.
```r
> x = seq(length = 5, from = 0, by = 10)
> x
[1]  0 10 20 30 40
> y = 1:5
> y
[1] 1 2 3 4 5
> x + y
[1]  1 12 23 34 45
> x - y
[1] -1  8 17 26 35
> x * y
[1]   0  20  60 120 200
> x / y
[1] 0.000000 5.000000 6.666667 7.500000 8.000000
```

##### Recycling
연산에 사용 되는 두 벡터의 길이가 다른 경우 길이가 짧은 벡터의 요소들이 순환 반복되어 사용된다. 이러한 현상을 recycling이라고 한다.
```r
> z = rep(x, times = 2)
> z
 [1]  0 10 20 30 40  0 10 20 30 40
> z + y
 [1]  1 12 23 34 45  1 12 23 34 45
> w = c(z, 50)
> w
 [1]  0 10 20 30 40  0 10 20 30 40 50
> w + y
 [1]  1 12 23 34 45  1 12 23 34 45 51
Warning message: # 길이가 다른 경우에 재사용되지만 배수가 아닌 경우는 경고 메시지가 출력됨
In w + y : longer object length is not a multiple of shorter object length


> x = 1:5
> 10 * x
[1] 10 20 30 40 50
> x + 10
[1] 11 12 13 14 15
> 10/x
[1] 10.000000  5.000000  3.333333  2.500000  2.000000
> x^2
[1]  1  4  9 16 25

```

|함수명|함수 설명|
|:--|:--|
|length(x)|벡터 x의 길이를 반환한다.|
|sum(x)|벡터 x에 있는 모든 요소들을 더한 결과를 반환한다.|
|mean(x)|벡터 x에 있는 요소들의 평균을 반환한다.|
|var(x)|벡터 x에 있는 요소들의 분산을 반환한다.|
|sd(x)|벡터 x에 있는 요소들의 표준편차를 반환한다.|
|range(x)|벡터 x에 있는 요소들의 최소값과 최대값을 반환한다.|
|min(x)/max(x)|벡터 x에 있는 요소들의 최소값/최대값을 반환한다.|
|median(x)|벡터 x에 있는 요소들의 중위수를 반환한다.|
|rank(x)|벡터 x의 각 요소를 작은 것에서 큰 것까지 순위를 반환한다.|
|sort(x)|벡터 x의 각 요소를 순서대로 배열한다.|
|order(x)|벡터 x의 요소의 값이 가장 작은 것부터|
||가장 큰 것까지 순서대로 요소의 위치를 반환한다.|
|which.max(x)|벡터 x의 최대값/최소값의 위치를 반환한다.|
|which.min(x)||
|which(x)|벡터 x에서 조건을 만족하는 요소의 위치를 반환한다.|
```r
> x = c(11, 3, 4, 20, 5)
> x
[1] 11  3  4 20  5
> length(x)
[1] 5
> sum(x)
[1] 43
> mean(x)
[1] 8.6
> var(x)
[1] 50.3
> sum( ((x - mean(x))^2 ) / ( length(x) - 1))
[1] 50.3
> sd(x)
[1] 7.092249
> range(x)
[1]  3 20


> min(x)
[1] 3
> max(x)
[1] 20
> median(x)
[1] 5

> which.max(x)
[1] 4
> which.min(x)
[1] 2
> which(x)
Error in which(x) : argument to 'which' is not logical
> which(x > 10)
[1] 1 4
> which(x > 10 & x < 15)
[1] 1
```

##### 벡터의 순서 및 정렬 관련 함수
벡터 요소들의 크기 순서, 정렬을 해주는 `rank(), order(), sort()`함수가 있다. 
```r
> x
[1] 11  3  4 20  5

> rank(x) # 등수, 크기 순서
[1] 4 1 2 5 3

> sort(x) # 순서대로 정렬
[1]  3  4  5 11 20

> order(x) # 큰 숫대로 정렬 순서 
[1] 2 3 5 1 4
```



# 논리 벡터
R은 숫자뿐 아니라 논리값으로 구성된 벡터를 만들 수 있다. 논리 벡터의 요소들은 `TRUE, FALSE, NA(not available)`이다.

##### c()로 논리 벡터 생성
```r
# 논리 벡터 생성시 T와 F만 입력하여도 TRUE, FALSE로 인식한다.
> a <- c(T, F, T); a
[1]  TRUE FALSE  TRUE

```

##### 비교 연산으로 논리 벡터 만들기
```r
> y = 1:5
> y > 3
[1] FALSE FALSE FALSE  TRUE  TRUE
> y >= 3
[1] FALSE FALSE  TRUE  TRUE  TRUE

> y < 5
[1]  TRUE  TRUE  TRUE  TRUE FALSE
> y <= 5
[1] TRUE TRUE TRUE TRUE TRUE

> y == 2
[1] FALSE  TRUE FALSE FALSE FALSE
> y != 2
[1]  TRUE FALSE  TRUE  TRUE  TRUE

```

##### 논리 연산으로 논리 벡터 만들기
기존 논리 벡터들에 대해 논리 연산을 수행하여 논리 벡터를 만들 수도 있다.
```r
> b = !a; b #not
[1] FALSE  TRUE FALSE

> a & b # and
[1] FALSE FALSE FALSE

> a | b #or
[1] TRUE TRUE TRUE
```

##### 논리 벡터 함수: any()& all()
```r
# any 하나라도 T가 있으면 TRUE
> any( c(F, F, F))
[1] FALSE
> any( c(F, F, T))
[1] TRUE

# all 모두가 T이면 TRUE
> all( c(F, F, T))
[1] FALSE
> all( c(T, T, T))
[1] TRUE


> c = cars$dist
> c
 [1]   2  10   4  22  16  10  18  26  34  17  28  14  20  24  28  26  34  34  46  26  36  60  80  20  26
[26]  54  32  40  32  40  50  42  56  76  84  36  46  68  32  48  52  56  64  66  54  70  92  93 120  85
> any(c > 100)
[1] TRUE
> any(c > 200)
[1] FALSE
> all(c > 5)
[1] FALSE
> all(c > 0) # for checking data errors
[1] TRUE
```


##### ifelse()
ifelse() 함수는 논리 벡터를 이용하는 또 다른 벡터 연산 함수이다. 
ifelse(x, a, b) 
- x : 논리 벡터
- a & b :  x의 길이와 동일한 벡터
x의 요소가 TRUE 면 벡터 a 요소
x의 요소가 FALSE 면 벡터 b 요소
```r
> x = c(T, F, F, T, F)
> a = 1:5
> b = -1:-5
> y = ifelse(x, a, b); y
[1]  1 -2 -3  4 -5

# 논리 벡터가 직접 부여되기보다는 비교 연산의 결과가 부여되는 경우가 많다. y에서 양수인 요소는 그대로 두고, 0이하인 요소는 0이 되도록 하여 새로운 벡터를 만든다.
> y = ifelse(y > 0, y, 0)
> y
[1] 1 0 0 4 0
> y > 0
[1]  TRUE FALSE FALSE  TRUE FALSE
```