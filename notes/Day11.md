___
# 리스트에 함수 적용하기
행렬을 공부할 때 apply() 함수를 이용하여 행렬의 각 행 또는 각 열에 함수를 적용할 수 있다. 리스트에도 리스트 각 요소에 함수를 적용하는 lapply()와 sapply() 가 있다.

##### lapply()
기본 문법 구조 : `lappy(리스트, 함수)`
lappky() 숫자 벡터로 이루어진 리스트의 각 요소에 mean() 함수를 적용한 예이다. 어떤 객체에 함수를 적용할 때는 function(object) 형식으로 인수로 객체를 제공한다. 그러나 lapply() 에서는 첫 번째 인수로 리스트를 제공하고, 두번째 인수로 함수 객체를 제공한다.
``` R
> b <- list(1:5, 21:29, seq(2, 20, by=2)); b
[[1]]
[1] 1 2 3 4 5

[[2]]
[1] 21 22 23 24 25 26 27 28 29

[[3]]
 [1]  2  4  6  8 10 12 14 16 18 20

> mean(b[[1]])
[1] 3
> mean(b[[3]])
[1] 11
> lapply(b, mean)
[[1]]
[1] 3

[[2]]
[1] 25

[[3]]
[1] 11

> lapply(b, mean)[1]
[[1]]
[1] 3

> lapply(b, mean)[3]
[[1]]
[1] 11

> lapply(b, mean)[[1]]
[1] 3
> lapply(b, mean)[[3]]
[1] 11

# lapply() 결과 리스트의 요소 이름을 제공하면 결과에도 동일한 이름이 요소에 붙여진다.
> lapply(b, max)
[[1]]
[1] 5

[[2]]
[1] 29

[[3]]
[1] 20

> names(b) <- c("A", "B", "C")
> lapply(b, range)
$A
[1] 1 5

$B
[1] 21 29

$C
[1]  2 20
```

##### sapply() 함수
많은 경우에 최종 결과가 리스트보다는 벡터나 행렬 등의 간단한 형태로 제공되는 것이 편리하다. 이런 경우에는 sapply()를 사용한다. 
- sapply() vs lapply()
	- 동일한 문법 구조
	- 리스트가 아니라 가능한 벡터나 행렬처럼 반환됨
``` R
> sapply(b, length)
 A  B  C 
 5  9 10 
> sapply(b, range)
     A  B  C
[1,] 1 21  2
[2,] 5 29 20
> lb <- lapply(b, length)
> typeof(lb)
[1] "list"
> sb <- sapply(b, length)
> typeof(sb)
[1] "integer"

# 사용자 정의 함수의 적용
> sapply(b, function(x){
+   sum(x > 10)
+ })
A B C 
```


##### mapply() 함수
lapply() 와 sapply()가 하나의 리스트에 대해 각 요소에 함수를 적용한다면, mapply()는 다수의 리스트에 대해 같은 위치의 요소들에 함수를 적용하기 위한 함수이다. mapply()는 sapply()처럼 결과를 벡터나 행렬 등의 단순한 형태로 제공할 수 있으면 리스트가 아니라 단순한 형태로 결과를 제공한다.
`mapply(FUN, list_1(vector_1), ..., list_n(vector_n), MoreArgs=NULL)`
``` R
> a <- list(1:5, 10:5, letters[1:4])
> b <- list(6:4, 4:7, LETTERS[5:1])
> mapply(c, a, b)
[[1]]
[1] 1 2 3 4 5 6 5 4

[[2]]
 [1] 10  9  8  7  6  5  4  5  6  7

[[3]]
[1] "a" "b" "c" "d" "E" "D" "C" "B" "A"

> a
[[1]]
[1] 1 2 3 4 5

[[2]]
[1] 10  9  8  7  6  5

[[3]]
[1] "a" "b" "c" "d"

> b
[[1]]
[1] 6 5 4

[[2]]
[1] 4 5 6 7

[[3]]
[1] "E" "D" "C" "B" "A"

```


## 리스트 활용 분야
##### 리스트로 결과를 반환하는 함수의 예
이 장의 시작부분에서 리스트가 중요한 이유를 설명할 때, 많은 데이터 분석 함수들이 결과를 리스트 형태로 제공한다고 하였다. 실제 그러한지 예를 통해 살펴보도록 한다.
lm() 함수는 선형회귀분석을 수행한다. 
``` R
> x <- lm(dist~speed, data = cars); x

Call:
lm(formula = dist ~ speed, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

> typeof(x)
[1] "list"
> class(x)
[1] "lm"
> names(x)
 [1] "coefficients"  "residuals"     "effects"       "rank"          "fitted.values" "assign"        "qr"           
 [8] "df.residual"   "xlevels"       "call"          "terms"         "model"        
> x$residuals
         1          2          3          4          5          6          7          8          9         10         11 
  3.849460  11.849460  -5.947766  12.052234   2.119825  -7.812584  -3.744993   4.255007  12.255007  -8.677401   2.322599 
        12         13         14         15         16         17         18         19         20         21         22 
-15.609810  -9.609810  -5.609810  -1.609810  -7.542219   0.457781   0.457781  12.457781 -11.474628  -1.474628  22.525372 
        23         24         25         26         27         28         29         30         31         32         33 
 42.525372 -21.407036 -15.407036  12.592964 -13.339445  -5.339445 -17.271854  -9.271854   0.728146 -11.204263   2.795737 
        34         35         36         37         38         39         40         41         42         43         44 
 22.795737  30.795737 -21.136672 -11.136672  10.863328 -29.069080 -13.069080  -9.069080  -5.069080   2.930920  -2.933898 
        45         46         47         48         49         50 
-18.866307  -6.798715  15.201285  16.201285  43.201285   4.268876 
> x$terms
dist ~ speed
attr(,"variables")
list(dist, speed)
attr(,"factors")
      speed
dist      0
speed     1
attr(,"term.labels")
[1] "speed"
attr(,"order")
[1] 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
attr(,"predvars")
list(dist, speed)
attr(,"dataClasses")
     dist     speed 
"numeric" "numeric" 

```
lm() 함수의 결과의 타입은 list이고, 클래스는 함수의 이름과 동일한 lm임을 볼 수 있다. 

##### unclass()
주의할 점은 리스트이긴 하지만 lm 클래스이므로 출력을 해 보면 리스트의 모든 요소가 출력되는 것이 아니라 lm 클래스에 맞추어 회귀분석의 주요 결과만 간략하게 출력됨을 볼 수 있다. 만약 리스트로서 모든 요소를 확인하고 싶으면 unclass() 함수를 이용 객체에 부여된 클래스 속성을 제거한다.
``` R
> unclass(x)
$coefficients
(Intercept)       speed 
 -17.579095    3.932409 

$residuals
         1          2          3          4          5          6          7          8          9         10         11 
  3.849460  11.849460  -5.947766  12.052234   2.119825  -7.812584  -3.744993   4.255007  12.255007  -8.677401   2.322599 
        12         13         14         15         16         17         18         19         20         21         22 
-15.609810  -9.609810  -5.609810  -1.609810  -7.542219   0.457781   0.457781  12.457781 -11.474628  -1.474628  22.525372 
        23         24         25         26         27         28         29         30         31         32         33 
 42.525372 -21.407036 -15.407036  12.592964 -13.339445  -5.339445 -17.271854  -9.271854   0.728146 -11.204263   2.795737 
        34         35         36         37         38         39         40         41         42         43         44 
 22.795737  30.795737 -21.136672 -11.136672  10.863328 -29.069080 -13.069080  -9.069080  -5.069080   2.930920  -2.933898 
        45         46         47         48         49         50 
-18.866307  -6.798715  15.201285  16.201285  43.201285   4.268876 

$effects
 (Intercept)        speed                                                                                            
-303.9144946  145.5522550   -8.1154395    9.8845605    0.1941147   -9.4963311   -5.1867770    2.8132230   10.8132230 
                                                                                                                     
  -9.8772228    1.1227772  -16.5676686  -10.5676686   -6.5676686   -2.5676686   -8.2581144   -0.2581144   -0.2581144 
                                                                                                                     
  11.7418856  -11.9485602   -1.9485602   22.0514398   42.0514398  -21.6390061  -15.6390061   12.3609939  -13.3294519 
                                                                                                                     
  -5.3294519  -17.0198977   -9.0198977    0.9801023  -10.7103435    3.2896565   23.2896565   31.2896565  -20.4007893 
                                                                                                                     
 -10.4007893   11.5992107  -28.0912352  -12.0912352   -8.0912352   -4.0912352    3.9087648   -1.4721268  -17.1625726 
                                                                 
  -4.8530184   17.1469816   18.1469816   45.1469816    6.4565358 

$rank
[1] 2

$fitted.values
        1         2         3         4         5         6         7         8         9        10        11        12 
-1.849460 -1.849460  9.947766  9.947766 13.880175 17.812584 21.744993 21.744993 21.744993 25.677401 25.677401 29.609810 
       13        14        15        16        17        18        19        20        21        22        23        24 
29.609810 29.609810 29.609810 33.542219 33.542219 33.542219 33.542219 37.474628 37.474628 37.474628 37.474628 41.407036 
       25        26        27        28        29        30        31        32        33        34        35        36 
41.407036 41.407036 45.339445 45.339445 49.271854 49.271854 49.271854 53.204263 53.204263 53.204263 53.204263 57.136672 
       37        38        39        40        41        42        43        44        45        46        47        48 
57.136672 57.136672 61.069080 61.069080 61.069080 61.069080 61.069080 68.933898 72.866307 76.798715 76.798715 76.798715 
       49        50 
76.798715 80.731124 

$assign
[1] 0 1

$qr
$qr
   (Intercept)         speed
1   -7.0710678 -1.088944e+02
2    0.1414214  3.701351e+01
3    0.1414214  1.887837e-01
4    0.1414214  1.887837e-01
5    0.1414214  1.617665e-01
6    0.1414214  1.347494e-01
7    0.1414214  1.077322e-01
8    0.1414214  1.077322e-01
9    0.1414214  1.077322e-01
10   0.1414214  8.071505e-02
11   0.1414214  8.071505e-02
12   0.1414214  5.369789e-02
13   0.1414214  5.369789e-02
14   0.1414214  5.369789e-02
15   0.1414214  5.369789e-02
16   0.1414214  2.668073e-02
17   0.1414214  2.668073e-02
18   0.1414214  2.668073e-02
19   0.1414214  2.668073e-02
20   0.1414214 -3.364315e-04
21   0.1414214 -3.364315e-04
22   0.1414214 -3.364315e-04
23   0.1414214 -3.364315e-04
24   0.1414214 -2.735359e-02
25   0.1414214 -2.735359e-02
26   0.1414214 -2.735359e-02
27   0.1414214 -5.437075e-02
28   0.1414214 -5.437075e-02
29   0.1414214 -8.138792e-02
30   0.1414214 -8.138792e-02
31   0.1414214 -8.138792e-02
32   0.1414214 -1.084051e-01
33   0.1414214 -1.084051e-01
34   0.1414214 -1.084051e-01
35   0.1414214 -1.084051e-01
36   0.1414214 -1.354222e-01
37   0.1414214 -1.354222e-01
38   0.1414214 -1.354222e-01
39   0.1414214 -1.624394e-01
40   0.1414214 -1.624394e-01
41   0.1414214 -1.624394e-01
42   0.1414214 -1.624394e-01
43   0.1414214 -1.624394e-01
44   0.1414214 -2.164737e-01
45   0.1414214 -2.434909e-01
46   0.1414214 -2.705080e-01
47   0.1414214 -2.705080e-01
48   0.1414214 -2.705080e-01
49   0.1414214 -2.705080e-01
50   0.1414214 -2.975252e-01
attr(,"assign")
[1] 0 1

$qraux
[1] 1.141421 1.269835

$pivot
[1] 1 2

$tol
[1] 1e-07

$rank
[1] 2

attr(,"class")
[1] "qr"

$df.residual
[1] 48

$xlevels
named list()

$call
lm(formula = dist ~ speed, data = cars)

$terms
dist ~ speed
attr(,"variables")
list(dist, speed)
attr(,"factors")
      speed
dist      0
speed     1
attr(,"term.labels")
[1] "speed"
attr(,"order")
[1] 1
attr(,"intercept")
[1] 1
attr(,"response")
[1] 1
attr(,".Environment")
<environment: R_GlobalEnv>
attr(,"predvars")
list(dist, speed)
attr(,"dataClasses")
     dist     speed 
"numeric" "numeric" 

$model
   dist speed
1     2     4
2    10     4
3     4     7
4    22     7
5    16     8
6    10     9
7    18    10
8    26    10
9    34    10
10   17    11
11   28    11
12   14    12
13   20    12
14   24    12
15   28    12
16   26    13
17   34    13
18   34    13
19   46    13
20   26    14
21   36    14
22   60    14
23   80    14
24   20    15
25   26    15
26   54    15
27   32    16
28   40    16
29   32    17
30   40    17
31   50    17
32   42    18
33   56    18
34   76    18
35   84    18
36   36    19
37   46    19
38   68    19
39   32    20
40   48    20
41   52    20
42   56    20
43   64    20
44   66    22
45   54    23
46   70    24
47   92    24
48   93    24
49  120    24
50   85    25

```


##### 데이터 프레임
리스트가 중요한 또 다른 이유는 R에서 데이터를 저장할 때 빈번하게 이용하는 데이터 프레임이라는 형식이 리스트를 기반으로 하고 있기 때문이다. data.frame -> 클래스 속성을 갖는 리스트
``` R
> head(cars)
  speed dist
1     4    2
2     4   10
3     7    4
4     7   22
5     8   16
6     9   10
> typeof(cars)
[1] "list"
> class(cars)
[1] "data.frame"
> unclass(cars)
$speed
 [1]  4  4  7  7  8  9 10 10 10 11 11 12 12 12 12 13 13 13 13 14 14 14 14 15 15 15 16 16 17 17 17 18 18 18 18 19 19 19 20
[40] 20 20 20 20 22 23 24 24 24 24 25

$dist
 [1]   2  10   4  22  16  10  18  26  34  17  28  14  20  24  28  26  34  34  46  26  36  60  80  20  26  54  32  40  32
[30]  40  50  42  56  76  84  36  46  68  32  48  52  56  64  66  54  70  92  93 120  85

attr(,"row.names")
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
[40] 40 41 42 43 44 45 46 47 48 49 50
```
speed와 dist로 이름이 붙여진 숫자 벡터로 구성된 리스트임을 확인할 수 있다. 그리고 row.names라는 속성이 부여되어 있음을 확인할 수 있다.

데이터 프레임은 보통 다른 통계 소프트웨어에서 데이터 집합 또는 데이터 행렬이라고 불리는 것이다. R에서는 본질적으로 데이터 프레임은 data.frame 클래스인 리스트인데, 요소의 길이가 모두 같은 리스트이다. 그러므로 데이터를 행렬 형태로 표현할 수 있다. 리스트의 각 요소가 각 열로 표현된다.

##### as.data.frame()
list -> data frame
``` R
> y <- list(a = 11:15, b = letters[11:15]); y
$a
[1] 11 12 13 14 15

$b
[1] "k" "l" "m" "n" "o"

> typeof(y); class(y)
[1] "list"
[1] "list"
> z <- as.data.frame(y); z
   a b
1 11 k
2 12 l
3 13 m
4 14 n
5 15 o
> typeof(z); class(z)
[1] "list"
[1] "data.frame"
```


# Chapter 6 R data frame
##### 데이터 프레임의 두 측면
- 리스트적 측면
	- 각 열마다 각기 다른 타입의 데이터를 가질 수 있다.
- 행렬적 측면
	- 행렬을 일반화한 것으로 보인다.
-> 데이터 프레임은 본질적으로 리스트이다.


### 범주형 데이터와 요인(Factors)
R 데이터 프레임의 각 열은 숫자, 문자, 논리 값 벡터 또는 요인으로 구성된다.

#### 명목형 변수와 요인
##### 범주 데이터의 숫자 코딩
10 명의 유전자에게 응답을 얻었다면 아마도 1부터 4까지의 숫자를 이용하여 다음과 같이 설문 결과를 입력하게 될 것이다.
``` R
> results <- c(1,3,2,4,3,2,1,3,2,2); results
 [1] 1 3 2 4 3 2 1 3 2 2
"""
여기서 숫자로 코딩된 설문 결과는 1부터 4까지의 수량적 의미를 가지기보다는 4가지 범주의 차이를 숫자로 표현한 것 뿐이다. 그런데 이렇게 범주형 데이터를 숫자 벡터로 표현하는 것은 범주형 데이터를 편리하게 코딩할 수 있는 장점이 있는 반면 다음과 같은 단점을 가진다.

숫자 코딩의 문제점
- 결과가 숫자 벡터로 입력되었으므로 다음처럼 어떤 범주에도 대응되지 않는 잘못된 숫자가 입력될 수 있다.
- 범주형 데이터를 숫자 데이터로 오인하여 잘못된 분석
- 데이터 입력 후 제대로 기록해 두지 않으면 각 숫자의 의미가 무엇인지 파악하기 어렵게 된다.
"""
> results[1] <- 5; results
 [1] 5 3 2 4 3 2 1 3 2 2
> mean(results)
[1] 2.7
```

##### factor()
이러한 문제를 해결하기 위해 R은 범주형 데이터를 처리할 때 이용할 수 있는 factor라는 형태의 데이터를 제공한다.
##### levels
1, 2, 3, 4 level을 가진 요인을 생성한
```R
> results
 [1] 5 3 2 4 3 2 1 3 2 2
> attributes(results)
NULL

> fResults <- factor(results, levels = 1:4); fResults
 [1] <NA> 3    2    4    3    2    1    3    2    2   
Levels: 1 2 3 4

> attributes(fResults)
$levels
[1] "1" "2" "3" "4"

$class
[1] "factor"
# 결과에서 보듯이 수준에 포함되지 않은 5의 값은 NA로 변환된다. 요인으로 변경된 데이터의 클래스는 factor가 되고, levels 속성이 지정되어 있음을 볼 수 있다.

> results[1] <- 1
> fResults <- factor(results, levels=1:4); fResults
 [1] 1 3 2 4 3 2 1 3 2 2
Levels: 1 2 3 4
> fResults[12] <- 5
Warning message:
In `[<-.factor`(`*tmp*`, 12, value = 5) :
  invalid factor level, NA generated
> fResults
 [1] 1    3    2    4    3    2    1    3    2    2    <NA> <NA>
Levels: 1 2 3 4
> fResults[12] <- 2; fResults
 [1] 1    3    2    4    3    2    1    3    2    2    <NA> 2   
Levels: 1 2 3 4
> fResults[11] <- 4; fResults
 [1] 1 3 2 4 3 2 1 3 2 2 4 2
Levels: 1 2 3 4
> mean(fResults)
[1] NA
Warning message:
In mean.default(fResults) :
  argument is not numeric or logical: returning NA

> levels(fResults)
[1] "1" "2" "3" "4"
> levels(fResults) <- c("A", "B", "C", "None")
> fResults
 [1] A    C    B    None C    B    A    C    B    B    None B   
Levels: A B C None

> typeof(fResults)
[1] "integer"
> class(fResults)
[1] "factor"
> unclass(fResults)
 [1] 1 3 2 4 3 2 1 3 2 2 4 2
attr(,"levels")
[1] "A"    "B"    "C"    "None"
> levels(fResults)
[1] "A"    "B"    "C"    "None"
> fResults[11] <- 4
Warning message:
In `[<-.factor`(`*tmp*`, 11, value = 4) :
  invalid factor level, NA generated
> fResults[12] <- "None"; fResults
 [1] A    C    B    None C    B    A    C    B    B    <NA> None
Levels: A B C None
```

#### 순서형 변수와 요인
범주형 데이터는 앞의 예처럼 범주 간에 순서가 없는 명목형 데이터도 있지만, 범주 간에 순서가 있는 순서형 데이터도 있다.
``` R
> satisfaction <- c("매우 불만", "매우 만족", "불만", "만족", "보통","불만", "매우 불만", "보통", "매우 만족", "불만")
> fsatisfaction <- factor(satisfaction,
+                         levels = c("매우 불만", "불만", "보통", "만족", "매우 만족"))
> fsatisfaction
 [1] 매우 불만 매우 만족 불만      만족      보통      불만      매우 불만 보통      매우 만족 불만     
Levels: 매우 불만 불만 보통 만족 매우 만족
> fsatisfaction >= "만족"
 [1] NA NA NA NA NA NA NA NA NA NA
Warning message:
In Ops.factor(fsatisfaction, "만족") : ‘>=’ not meaningful for factors

```

##### ordered 인수로 순서형 변수 만들기
명목형 데이터를 나타내는 요인의 숫자는 각 범주를 표현하는 의미를 가지므로 앞의 맨 마지막 예처럼 순서를 비교하는 연산을 수행할 수 없다.
``` R
> oSatisfaction <- factor(satisfaction, ordered = TRUE,
+                         levels = c("매우 불만", "불만", "보통", "만족", "매우 만족")); oSatisfaction
 [1] 매우 불만 매우 만족 불만      만족      보통      불만      매우 불만 보통      매우 만족 불만     
Levels: 매우 불만 < 불만 < 보통 < 만족 < 매우 만족
> oSatisfaction >= "만족"
 [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE
> sum(oSatisfaction >= "만족")
[1] 3
> mean(oSatisfaction >= "만족")
[1] 0.3
> order(oSatisfaction)
 [1]  1  7  3  6 10  5  8  4  2  9
> oSatisfaction
 [1] 매우 불만 매우 만족 불만      만족      보통      불만      매우 불만 보통      매우 만족 불만     
Levels: 매우 만족 < 만족 < 보통 < 불만 < 매우 불만
> oSatisfaction >= "만족"
 [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE
> sum(oSatisfaction >= "만족")
[1] 8
> mean(oSatisfaction >= "만족")
[1] 0.8
> 
> order(oSatisfaction)
 [1]  2  9  4  5  8  3  6 10  1  7
 
```

##### 수준의 순서
순서형이 아닌 명목형 범주 데이터 factor()로 만들어지고 이 때도 levels에 주어진 순서로, 범주(수준)가 내부적으로 저장되는 숫자가 결정된다. levels에 언급된 수준의 순서대로 1번 부터 차례로 숫자가 부여된다. 순서형 범주 데이터처럼 순서가 데이터 분석에 핵심적인 역할을 하지는 않지만, 그래프나 표가 표현될 때 이 범주(수준)의 순서대로 출력되므로, 범주를 원하는 순서대로 출력하고자 하면 levels 인수에 수준의 순서를 명시하는 것이 좋다.
``` R
> a <- c("F", "M", "F", "M", "F")
> fa1 <- factor(a); fa1
[1] F M F M F
Levels: F M
> unclass(fa1)
[1] 1 2 1 2 1
attr(,"levels")
[1] "F" "M"
> table(fa1)
fa1
F M 
3 2 
> fa2 <- factor(a, levels = c("M", "F"))
> fa2
[1] F M F M F
Levels: M F
> unclass(fa2)
[1] 2 1 2 1 2
attr(,"levels")
[1] "M" "F"
> table(fa2)
fa2
M F 
2 3 
```

##### `relevel()`과 `reorder()`를 이용한 수준의 순서 변경
앞의 예에서는 `factor()` 함수의 `levels` 인수를 사용하여 수준의 순서를 바꾸는 방법을 보았다. 이러한 방법은 수준의 수가 적을 때는 편리한 방법이지만, 수준의 수가 많으면 모든 수준을 `levels` 인수에 나열하여야 하기 때문에 불편하다.
`factor()` 함수의 `levels` 인수에 모든 수준을 다시열해 주어야 하므로 불편하다. 이러한 경우에는 `relevel()` 함수를 사용하면 원하는 결과를 쉽게 얻을 수 있다.
``` R
> fResults
 [1] A    C    B    None C    B    A    C    B    B    <NA> None
Levels: A B C None
> fResults2 <- relevel(fResults, ref = "None"); fResults2
 [1] A    C    B    None C    B    A    C    B    B    <NA> None
# `relevel()` 함수의 `ref` 인수에 맨 앞에 나타날 수준을 지정하면 나머지 수준의 순서는 변하지 않고 지정된 수준만 앞으로 이동

Levels: None A B C
> table(fResults2)
fResults2
None    A    B    C 
   2    2    4    3 


# InsectSprays: 살충제의 종류(spray), 해충의 수(count)
> head(InsectSprays)
  count spray
1    10     A
2     7     A
3    20     A
4    14     A
5    14     A
6    12     A
> InsectSprays$spray
 [1] A A A A A A A A A A A A B B B B B B B B B B B B C C C C C C C C C C C C D D D D D D D D D D D D E E E E E E E E E E E
[60] E F F F F F F F F F F F F
Levels: A B C D E F
> boxplot(count ~ spray, data = InsectSprays)
> boxplot(count ~ reorder(spray, count, median), data=InsectSprays)
```
그런데 이런 데이터는 살충력이 높은 것에서 낮은 것 순으로 배열되는 것이 더 이해하기가 쉽다. 그러한 형태로 그래프를 그리려면 요인이 `spray` 열의 수준이 `count`의 중위수가 낮은 것부터 높은 것 순으로 정렬되어야 한다. `reorder()` 함수를 사용하면 이러한 수준의 변경을 손 쉽게 할 수 있다. `reorder()`는 첫 번째 인수로 요인을, 두 번째 인수로 요인의 수준을 결정할 다른 수치 벡터를, 세 번째 인수로 수치 벡터에 적용할 통계 함수를 지정한다. 그러면 수치 벡터를 요인의 수준 별로 나누어 통계 함수를 적용한 후, 가장 낮은 값에서 큰 값으로 수준의 순서를 재정렬한다.

##### labels 인수
요인을 만든 후 기존의 수준을 변경하고 싶으면 levels() 함수를 이용하여 새로운 수준을 할당한다고 설명
그러나 요인을 만들 때 기존에 코딩된 수준을 바로 변경하고 싶을 수가 있다
factor() 함수에 labels 인수를 이용하면 기존의 수준이 labels 인수에 주어진 형태로 변경
주의할 점은 levels 인수는 원래 데이터가 코딩된 형태로 정의되어야 하고, labels 인수는 바꿀 코딩 형태로 정의
``` R
> fa3 <- factor(a, levels = c("M", "F"), labels = c("Male", "Female")); fa3
[1] Female Male   Female Male   Female
Levels: Male Female
> unclass(fa3)
[1] 2 1 2 1 2
attr(,"levels")
[1] "Male"   "Female"
> table(fa3)
fa3
  Male Female 
     2      3 


> fa3[6] <- "M"
Warning message:
In `[<-.factor`(`*tmp*`, 6, value = "M") :
  invalid factor level, NA generated
> fa3[6] <- "Male"
> fa3
```

