___
# Character vector
문자 벡터는 문자를 요소로 하는 벡터이다. 범주형 데이터를 다루거나 데이터에 이름을 부여할 때 자주 이용된다.

##### 문자 벡터 만들기
```r
> students = c("한국", "Allen", "Tom")
> students
[1] "한국"  "Allen" "Tom"  

> n = 1:3
> n
[1] 1 2 3

# as.character(n) : 숫자나 논리 벡터를 문자 벡터로 전환할 수 잇다.
> num <- as.character(n)
> num
[1] "1" "2" "3"

```
##### paste()
문자 벡터에 많이 사용되는 연산 중 하나로 문자 벡터를 요소끼리 서로 연결시키는 연산이다.
```r
> paste(students, num)
[1] "한국 1"  "Allen 2" "Tom 3"  

> paste(students, num, sep="")
[1] "한국1"  "Allen2" "Tom3"  

> paste(students, num, sep = "-")
[1] "한국-1"  "Allen-2" "Tom-3"  

> paste(students, 1:2)
[1] "한국 1"  "Allen 2" "Tom 1"  

> paste(students, num, c("A", "B", "C"), "!")
[1] "한국 1 A !"  "Allen 2 B !" "Tom 3 C !" 
```
##### strsplit()
paste()와 반대로 문자열을 나눌 때 구분자로 사용할 문자열을 split 인수로 제공해야 한다.
```r
> x <- c("2015-3-15 10:12:12", "2016-10-11 11:12:14", "2024-11-25 02:03:04")
> x
[1] "2015-3-15 10:12:12"  "2016-10-11 11:12:14" "2024-11-25 02:03:04"
> strsplit(x, split = " ")
[[1]]
[1] "2015-3-15" "10:12:12" 

[[2]]
[1] "2016-10-11" "11:12:14"  

[[3]]
[1] "2024-11-25" "02:03:04"  

> strsplit(x, split = "-")
[[1]]
[1] "2015"        "3"           "15 10:12:12"

[[2]]
[1] "2016"        "10"          "11 11:12:14"

[[3]]
[1] "2024"        "11"          "25 02:03:04"

> strsplit(x, split = ":")
[[1]]
[1] "2015-3-15 10" "12"           "12"          

[[2]]
[1] "2016-10-11 11" "12"            "14"           

[[3]]
[1] "2024-11-25 02" "03"            "04"           

> strsplit(x, split = c("-",":"," "))
[[1]]
[1] "2015"        "3"           "15 10:12:12"

[[2]]
[1] "2016-10-11 11" "12"            "14"           

[[3]]
[1] "2024-11-25" "02:03:04"  

```
##### nchar()
문자 벡터의 각 요소의 문자 개수를 알려 준다. 공백도 문자이므로 문자 개수를 셀 때 포함이 된다는데 주의한다.
```r
> nchar("Day")
[1] 3

> a <- c("날짜", "day", "date", "day and time")
> nchar(a)
[1]  2  3  4 12
```

| 함수명                                                  | 함수 설명                                                       |
| :--------------------------------------------------- | :---------------------------------------------------------- |
| nchar(x)                                             | 벡터 x의 문자열 요소의 문자 수를 반환한다.                                   |
| substr(x, start, stop)                               | 벡터 x의 문자열 요소의 start번째 문자부터 stop번째 문자까지의 부분 문자열을 출력한다.       |
| grep(pattern, x, ignore.case=F, fixed=F)             | 벡터 x의 문자열 요소에 pattern 문자열 요소가 있는지 검색한다. pattern은 정규식일 수 있다. |
| sub(pattern, replacement, x, ignore.case=F, fixed=F) | 벡터 x의 문자열 요소에서 pattern을 찾아 replacement로 대체한다.               |
| strsplit(x, split, fixed=F)                          | 벡터 x의 문자열 요소를 split에서 분리한 결과를 반환한다.                         |
| paste(…, sep=’ ’)                                    | 문자 벡터를 sep를 이용하여 결합시킨 결과를 반환한다.                             |
| toupper(x)                                           | 벡터 x의 문자열 요소를 대문자로 변환한다.                                    |
| tolower(x)                                           | 벡터 x의 문자열 요소를 소문자로 변환한다.                                    |


# Missing Values
### NA
-> R에서는 데이터에 결측치가 있을 때 이를 NA 값으로 표시한다.

##### is.na()와 na.omit()
```r
> z <- c(11:13, NA)
> z
[1] 11 12 13 NA

> is.na(z) # NAN 결측치이면 TRUE로 반환한다.
[1] FALSE FALSE FALSE  TRUE

> na.omit(z) # 결측치의 위치를 반환하고 결측치를 제외한 벡터를 만들 수 있다.
[1] 11 12 13
attr(,"na.action")
[1] 4
attr(,"class")
[1] "omit"
```

##### na.rm 인수
sum(), mean() 함수 등의 결과에서 NA가 포함되면 NA로 나오기 때문에 na.rm = TRUE로 결측치를 제외한 값을 구하게 한다.
```r
> sum(z)
[1] NA
> sum(z, na.rm = TRUE)
[1] 36
```

##### NaN
결측치는 아니지만 데이터의 값을 결정할 수 없는 경우가 있다. 대표적인 경우가 0에서 0을 나누는 경우이다. 이 경우 숫자 연산의 결과를 결정할 수 없으므로 NaN(Not a Number)로 결과를 표현된다. 주의할 점은 R은 무한대로 숫자로 간주하므로, 무한대의 결과가 나올 때는 Inf로 결과를 표현한다.
```r
> 1/0
[1] Inf

> Inf * 5
[1] Inf

> 0/0
[1] NaN

> Inf - Inf
[1] NaN
```

##### is.nan()
```r
# is.na() : NaN 와 NA을 TRUE로 반환한다.
# is.nan() : NaN 만 TRUE로 반환한다.

> z <- -1:1 / 0
> z
[1] -Inf  NaN  Inf

> is.na(z)
[1] FALSE  TRUE FALSE

> r <- c(z, NA)
> r
[1] -Inf  NaN  Inf   NA

> is.na(r)
[1] FALSE  TRUE FALSE  TRUE

> is.nan(r)
[1] FALSE  TRUE FALSE FALSE
```


# 인덱스 벡터와 필터링
데이터를 분석하다 보면, 데이터의 특정 요소만 추출하여 분석해 보고 싶을 때가 있다. 40세 이상의 고객만 추출하여 분석 한다든지, 남자 학생에 대해서만 별도의 분석을 하는 경우가 그러한 예라고 할 수 있다. 이렇게 데이터에서 특정 부분만 추출하여 새로운 데이터를 만드는 작업을 필터링이라고 한다.
```r
vector[index_vector]
```
인텍스 벡터는 자연수 벡터, 음의 정수 벡터, 논리 벡터, 이름 벡터 4가지 형태를 가진다.

##### 자연수 인덱스 벡터
```r
> x <- 11:20
> x
 [1] 11 12 13 14 15 16 17 18 19 20
 
> x[6]
[1] 16

> x[c(6, 10)]
[1] 16 20

> x[seq(3, 9, by=2)]
[1] 13 15 17 19

> x[rep(c(2,4), times=3)]
[1] 12 14 12 14 12 14

> x[6, 10]
Error in x[6, 10] : incorrect number of dimensions


> x <- c(7, 9, 4, 6, 13, 4, 1, 11)
> x[which.min(x)]
[1] 1

> x[which.max(x)]
[1] 13

> x[which(x > 10)]
[1] 13 11

> x[order(x)]
[1]  1  4  4  6  7  9 11 13
```

##### 음의 정수 인덱스 벡터
자연수 인덱스가 추출한 요소의 위치를 표현한다면, 음의 정수 인덱스는 추출하지 않은 요소의 위치를 표현한다. 따라서 벡터 필터링에 음의 정수 인덱스 벡터가 사용 되면, 데이터 벡터에서 해당 위치의 요소가 제외된 나머지 요소로 새로운 벡터를 만들어 반환한다.
```r
> x <- 11 : 20; x
 [1] 11 12 13 14 15 16 17 18 19 20
 
> x[-2]
[1] 11 13 14 15 16 17 18 19 20

> x[c(-2, -4)]
[1] 11 13 15 16 17 18 19 20

> x[-(3:6)]
[1] 11 12 17 18 19 20
```


##### 논리 인덱스 벡터
논리 인덱스는 추출한 요소는 TRUE, 추출하지 않은 요소는 FALSE로 표시한다. 인덱스 벡터가 논리 벡터로 주어지면 데이터 벡터에서 TRUE 위치의 요소만 선택되어 새로운 벡터가 만들어진다.
```r
> x = 1:5
> y = c(T, F, T, T, F)
> x[y]
[1] 1 3 4

> x > 3
[1] FALSE FALSE FALSE  TRUE  TRUE

> x[x>3]
[1] 4 5

> x > 3 & x < 5
[1] FALSE FALSE FALSE  TRUE FALSE

> x[x > 3 & x < 5]
[1] 4

> y <- c(TRUE, FALSE)
> x[y]
[1] 1 3 5
```

##### 이름 인덱스 벡터
R에선 벡터의 각 요소에 이름을 부여할 수 있다. 이름 인덱스 벡터는 추출할 요소의 위치를 벡터 요소의 이름으로 지정하는 방식이다. 벡터 요소의 이름은 names() 함수로 확인하거나 할당할 수 있다. 벡터의 요소에 이름을 부여하면, 벡터가 출력 될 때 데이터의 값뿐 아니라 요소의 이름도 함께 출력이 된다.
```r
> animals <- c(5, 7, 3, 2)
> animals
[1] 5 7 3 2
> names(animals) <- c("cats", "dogs", "camels", "donkeys")
> animals
   cats    dogs  camels donkeys 
      5       7       3       2 
      
> animals["camels"]
camels 
     3 
     
> animals[c("dogs", "donkeys")]
   dogs donkeys 
      7       2 
```


##### 인덱스 벡터를 이용해 벡터 요소에 값 할당하기
지금까지는 인덱스 벡터를 이용하여 필요한 요소를 추출하는 방법에 대해서 살펴보았다. 그런데 인덱스 벡터를 이용하여 데이터 벡터의 특정 요소에만 값을 할당할 수도 있다.
```r
> a <- 1:5; a
[1] 1 2 3 4 5

> a[2] <- 20; a
[1]  1 20  3  4  5

> a[c(3, 5)] <- c(100, 300); a
[1]   1  20 100   4 300

> a[c(1, 3, 5)] <- -5; a
[1] -5 20 -5  4 -5

> a[-1] <- 0; a
[1] -5  0  0  0  0

> x <- c(NA, 2:4, NA) ; x
[1] NA  2  3  4 NA

> x[is.na(x)] <- 0 ; x
[1] 0 2 3 4 0

> y <- c(-2, 0 , 4, -7, 8) ; y
[1] -2  0  4 -7  8

> y[y<0] <- -y[y<0]
> y
[1] 2 0 4 7 8
```