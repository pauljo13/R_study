___
# Matrix 2
### 4. 행렬의 연산
##### 행렬의 요소 단위 연산
행과 열의 수가 같은 행렬은 산술 연산을 할 수 있다. 이 경우 벡터와 마찬가지로 산술 연산은 같은 위치의 요소 단위(element-by-element)로 이루어진다.
```r
> A <- matrix(1:9, nrow = 3, ncol = 3); A
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
> B <- matrix(seq(from=10, length=9, by=10), nrow = 3, ncol = 3); B
     [,1] [,2] [,3]
[1,]   10   40   70
[2,]   20   50   80
[3,]   30   60   90
> A + B
     [,1] [,2] [,3]
[1,]   11   44   77
[2,]   22   55   88
[3,]   33   66   99
> B - A
     [,1] [,2] [,3]
[1,]    9   36   63
[2,]   18   45   72
[3,]   27   54   81
> A * B
     [,1] [,2] [,3]
[1,]   10  160  490
[2,]   40  250  640
[3,]   90  360  810
> B / A
     [,1] [,2] [,3]
[1,]   10   10   10
[2,]   10   10   10
[3,]   10   10   10
```
행렬은 재사용 되지 않는다.
행과 열의 개수가 다른 행렬의 산술연산은 오류를 발생시킨다. 그 이유로 행렬은 벡터와 달리 요소의 재사용이 일어나지 않기 때문이다. 그렇기 때문에 행렬과 행렬의 연산에서는 행과 열이 같은 크기이어야 한다.
```r
> C <- cbind(A, 10:12); C
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> B + c
Error in B + c : non-numeric argument to binary operator
> C <- rbind(A, 1:3); C
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
[4,]    1    2    3
> B * C
Error in B * C : non-conformable arrays
```
##### 벡터와 행렬의 연산: 벡터는 재사용된다.
벡터와 행렬의 산술연산도 같은 위치의 요소 단위로 이루어진다. 벡터 a와 행렬 A의 연산시 벡터 a는 먼저 행렬 A와 같은 차원의 행렬로 변환되어 연산이 수행된다. 만약 벡터의 길이가 행렬의 길이보다 작으면 벡터의 데이터는 행렬의 길이만큼 순환 재사용된다. 연산을 위해 벡터가 행렬로 변환될 때도 matrix()로 행렬이 만들어질 때와 마찬가지로 열 별로 데이터이를 채워나간다.
``` r
> a <- 9:1
> a + A
     [,1] [,2] [,3]
[1,]   10   10   10
[2,]   10   10   10
[3,]   10   10   10
> a <- c(0, 10, 100)
> a + A
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]   12   15   18
[3,]  103  106  109
> A * a
     [,1] [,2] [,3]
[1,]    0    0    0
[2,]   20   50   80
[3,]  300  600  900
> 10 * A
     [,1] [,2] [,3]
[1,]   10   40   70
[2,]   20   50   80
[3,]   30   60   90
> b <- 1:10
> b * A
Error: dims [product 9] do not match the length of object [10]
In addition: Warning message:
In b * A : longer o
```


### 5. 행렬과 함수
##### t()
 전치행렬(transposed matrix)을 만드는 함수
``` r
> A <- matrix(1:4, nrow = 2, ncol = 2); A
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> t(A)
     [,1] [,2]
[1,]    1    2
[2,]    3    4
```

##### nrow(), ncol(), dim()
- nrow() : 행의 수를 반환
- ncol() : 열의 수를 반환
- dim() : 행과 열의 차원 전체를 반환
```r
> nrow(A)
[1] 2
> ncol(A)
[1] 2
> dim(A)
[1] 2 2
> attributes(A)
$dim
[1] 2 2
```

##### rownames(), colnames()
- rownames() : 행의 이름을 설정
- colnames() : 열의 이름을 설정
```r
> rownames(A)
NULL
> colnames(A)
NULL
> rownames(A) <- c("upper", "lower")
> colnames(A) <- c("left", "right")
> A
      left right
upper    1     3
lower    2     4
> attributes(A)
$dim
[1] 2 2

$dimnames
$dimnames[[1]]
[1] "upper" "lower"

$dimnames[[2]]
[1] "left"  "right"
```

##### as.vector(), c()
```r
> X <- rbind(1:5, 5:1); X
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    5    4    3    2    1
> x <- as.vector(X); x
 [1] 1 5 2 4 3 3 4 2 5 1
> attributes(x)
NULL
> y <- c(X); y
 [1] 1 5 2 4 3 3 4 2 5 1
> attributes(y)
NULL
```

##### 행렬에 벡터 함수 적용
```r
> sum(X)
[1] 30
> mean(X)
[1] 3
> sd(X)
[1] 1.490712
> range(X)
[1] 1 5
```


##### apply()
`apply(X, MARGIN, FUN, ...)`
- X : 행렬 또는 열별로 함수를 적용할 행렬
- MARGIN : 함수를 적용할 방향을 지정
	- 1 : 행, 세로
	- 2 : 열, 가로
- FUN : 행이나 열별로 적용할 함수를 전달
``` r
> set.seed(123)
> a <- sample(1:25); a
 [1] 15 19 14  3 10 18 11  5 23  6  9 21 24 20 22 25 17  1 12 13  2 16  7  8  4
> A <- matrix(a, nrow = 5, ncol = 5); A
     [,1] [,2] [,3] [,4] [,5]
[1,]   15   18    9   25    2
[2,]   19   11   21   17   16
[3,]   14    5   24    1    7
[4,]    3   23   20   12    8
[5,]   10    6   22   13    4
> apply(A, 2, sum)
[1] 61 63 96 68 37
> apply(A, 1, sum)
[1] 69 84 51 66 55
> sum(A)
[1] 325
> colnames(A) <- LETTERS[1:5]
> rownames(A) <- paste("X", 1:5, sep = "")
> A
    A  B  C  D  E
X1 15 18  9 25  2
X2 19 11 21 17 16
X3 14  5 24  1  7
X4  3 23 20 12  8
X5 10  6 22 13  4
> apply(A, 1, min)
X1 X2 X3 X4 X5 
 2 11  1  3  4 
> apply(A, 2, max)
 A  B  C  D  E 
19 23 24 25 16 

# 함수의 결과 벡터이면 열로서 결합하여 출력
> apply(A, 2, range)
      A  B  C  D  E
[1,]  3  5  9  1  2
[2,] 19 23 24 25 16
> apply(A, 1, range)
     X1 X2 X3 X4 X5
[1,]  2 11  1  3  4
[2,] 25 21 24 23 22
> apply(A, 1, summary)
          X1   X2   X3   X4 X5
Min.     2.0 11.0  1.0  3.0  4
1st Qu.  9.0 16.0  5.0  8.0  6
Median  15.0 17.0  7.0 12.0 10
Mean    13.8 16.8 10.2 13.2 11
3rd Qu. 18.0 19.0 14.0 20.0 13
Max.    25.0 21.0 24.0 23.0 22

```
- range() : 최소값과 최대값이라는 두 요소로 이루어진 벡터를 결과로서 반환
- summary() : 최소값, 사분위수, 최대값, 평균 등


### 배열
##### 배열의 생성
벡터는 일차원 데이터 구조로 하나의 인덱스 벡터로 요소의 위치를 지정
```r
> x <- 11:20; x
 [1] 11 12 13 14 15 16 17 18 19 20
> x[1]
[1] 11
> x[6:7]
[1] 16 17
> x <- matrix(11:19, nrow = 3, ncol = 3); x
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   15   18
[3,]   13   16   19
> x[1,2]
[1] 14
> x[2:3, 1]
[1] 12 13
```


##### array()
`array(data, dim)`
```r
> x <- array(11:28, dim = c(3,3,2)); x
, , 1

     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   15   18
[3,]   13   16   19

, , 2

     [,1] [,2] [,3]
[1,]   20   23   26
[2,]   21   24   27
[3,]   22   25   28
```

##### 3차원 배열의 출력 방식
행렬과 마찬가지로 3차원 배열의 첫번째 차원은 행을, 두번째 차원은 열을, 세번째 차원은 층(layers)을 나타낸다. 3차원 배열의 경우 컴퓨터 화면은 2차원이기 때문이 각 층을 차례로 보여주는 방식으로 배열의 요소를 출력
',,(층 번호)'
##### 3차원 배열에서 데이터가 채워지는 순서
행렬과 마찬가지로 앞 차원의 인덱스들이 먼저 변하며 데이터가 채워진다. 1층의 데이터가 다 채워진 후 2층의 데이터가 채워지고, 동일 층에서는 앞의 열이 먼저 채워지고 뒤의 열이 다음에 채워진다. 동일 층의 동일 열에서는 앞의 행의 먼저 채워지고 뒤의 행이 다음에 채워진다.
##### k차원 배열은 k개의 인덱스 벡터로 요소의 위치를 지정
3차원 배열에서 요소의 위치를 지정하기 위해서는 3개의 인덱스 벡터가 필요하다. 마찬가지로 k-차원의 배열에서 요소의 위치를 지정하기 위해서는 k개의 인덱스 벡터가 필요하다.
```r
> x[2, 1, 1]
[1] 12
> x[2, 1, 2]
[1] 21
> x[1, 2:3, 2]
[1] 23 26
> x <- array(11:19, c(3,3)); x
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   15   18
[3,]   13   16   19
```

##### 벡터를 재사용하여 배열 만들기
```r
> x <- array(1, dim = c(2, 3, 2));x
, , 1

     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    1    1

, , 2

     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    1    1

> x <- array(1:6, dim = c(3, 3, 2));x
, , 1

     [,1] [,2] [,3]
[1,]    1    4    1
[2,]    2    5    2
[3,]    3    6    3

, , 2

     [,1] [,2] [,3]
[1,]    4    1    4
[2,]    5    2    5
[3,]    6    3    6

> x <- array(1:5, dim = c(3, 3, 2));x
, , 1

     [,1] [,2] [,3]
[1,]    1    4    2
[2,]    2    5    3
[3,]    3    1    4

, , 2

     [,1] [,2] [,3]
[1,]    5    3    1
[2,]    1    4    2
[3,]    2    5    3

> x <- array(1:30, dim = c(3, 3, 2));x
, , 1

     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9

, , 2

     [,1] [,2] [,3]
[1,]   10   13   16
[2,]   11   14   17
[3,]   12   15   18
```

##### 4차원 배열 예
```r
> y <- array(1:30, dim = c(2, 3, 2, 2)); y
, , 1, 1

     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

, , 2, 1

     [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8   10   12

, , 1, 2

     [,1] [,2] [,3]
[1,]   13   15   17
[2,]   14   16   18

, , 2, 2

     [,1] [,2] [,3]
[1,]   19   21   23
[2,]   20   22   24
```


### 배열도 결국 벡터
##### 배열은 dim 속성을 가진 벡터이다.
행렬과 마찬가지로 배열도 사실 벡터이다. 그러므로 typeof() 함수를 이용하여 생성된 배열의 타입을 확인해 보면 숫자 벡터임을 보여준다. 그러나 class() 함수로 배열의 클래스를 확인하면 array 클래스로 처리됨을 볼 수 있다. 
``` r
> typeof(x)
[1] "integer"

> class(x)
[1] "array"

> attributes(x)
$dim
[1] 3 3 2
```

##### 벡터에 dim 속성을 부여하여 배열 만들기
``` r
> x <- 1:12
> dim(x)
NULL
> x
 [1]  1  2  3  4  5  6  7  8  9 10 11 12
> dim(x) <- c(3,4)
> x
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> dim(x) <- c(2, 3, 2)
> x
, , 1

     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

, , 2

     [,1] [,2] [,3]
[1,]    7    9   11
[2,]    8   10   12

> dim(x) <- NULL
> x
 [1]  1  2  3  4  5  6  7  8  9 10 11 12
```

##### dimnames & dimanmes() 함수
```r
> dim(x) <- c(2, 3, 2)
> dimnames(x) <- list(c("A", "B"),
+                     paste("group", 1:3, sep="-"),
+                     c("Male", "Female")); x
, , Male

  group-1 group-2 group-3
A       1       3       5
B       2       4       6

, , Female

  group-1 group-2 group-3
A       7       9      11
B       8      10      12

> attributes(x)
$dim
[1] 2 3 2

$dimnames
$dimnames[[1]]
[1] "A" "B"

$dimnames[[2]]
[1] "group-1" "group-2" "group-3"

$dimnames[[3]]
[1] "Male"   "Female"
```


#### 배열의 연산과 필터링
##### 배열의 요소 단위 연산
배열 연산과 필터링은 행렬 연산과 필터링의 경우와 동일한 원리로 작동한다.
```r
> a <- array(1:8, c(2, 2, 2)); a
, , 1

     [,1] [,2]
[1,]    1    3
[2,]    2    4

, , 2

     [,1] [,2]
[1,]    5    7
[2,]    6    8

> b <- array(10^(0:7), c(2,2,2)); b
, , 1

     [,1] [,2]
[1,]    1  100
[2,]   10 1000

, , 2

      [,1]  [,2]
[1,] 1e+04 1e+06
[2,] 1e+05 1e+07

> a + b
, , 1

     [,1] [,2]
[1,]    2  103
[2,]   12 1004

, , 2

       [,1]     [,2]
[1,]  10005  1000007
[2,] 100006 10000008

> a * b
, , 1

     [,1] [,2]
[1,]    1  300
[2,]   20 4000

, , 2

      [,1]  [,2]
[1,] 5e+04 7e+06
[2,] 6e+05 8e+07

> d <- array(11:30, c(2, 3, 2)); d
, , 1

     [,1] [,2] [,3]
[1,]   11   13   15
[2,]   12   14   16

, , 2

     [,1] [,2] [,3]
[1,]   17   19   21
[2,]   18   20   22

> a + d
Error in a + d : non-conformable arrays
> 2 * a
, , 1

     [,1] [,2]
[1,]    2    6
[2,]    4    8

, , 2

     [,1] [,2]
[1,]   10   14
[2,]   12   16

> 1:2 * a
, , 1

     [,1] [,2]
[1,]    1    3
[2,]    4    8

, , 2

     [,1] [,2]
[1,]    5    7
[2,]   12   16


# drop
> x
, , Male

  group-1 group-2 group-3
A       1       3       5
B       2       4       6

, , Female

  group-1 group-2 group-3
A       7       9      11
B       8      10      12

> x[ , , 2]
  group-1 group-2 group-3
A       7       9      11
B       8      10      12
> x[1, 2:3, 2]
group-2 group-3 
      9      11 
> x[1, 2:3, 1:2]
        Male Female
group-2    3      9
group-3    5     11
> x[1, 2:3, 1:2, drop=F]
, , Male

  group-2 group-3
A       3       5

, , Female

  group-2 group-3
A       9      11

> x[,-2,c(T,F)]
  group-1 group-3
A       1       5
B       2       6
> x["A", "group-2", "Female"]
[1] 9
```


### 7. 행렬과 배열의 고급 연산
##### 행렬의 곱
지금까지 행렬의 연산은 요소 단위로 이루어졌다. 따라서 행렬에 곱하기 연산자  * 를 사용하면 같은 위치의 요소끼리 곱해졌다. 그러나 수학에서 일반적으로 정의하는 행렬의 곱은 다음과 같은 형식으로 수행한다.
$$
\begin{bmatrix}
a & b \\
c & d
\end{bmatrix}
\times
\begin{bmatrix}
e & f \\
g & h
\end{bmatrix}
=
\begin{bmatrix}
b \cdot g + a \cdot e & b \cdot h + a \cdot f \\
d \cdot g + c \cdot e & d \cdot h + c \cdot f
\end{bmatrix}
$$
```r
> A <- array(1:4, c(2,2)); A
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> B <- array(10^(0:3), c(2,2)); B
     [,1] [,2]
[1,]    1  100
[2,]   10 1000
> A * B
     [,1] [,2]
[1,]    1  300
[2,]   20 4000
> B * A
     [,1] [,2]
[1,]    1  300
[2,]   20 4000
> A %*% B
     [,1] [,2]
[1,]   31 3100
[2,]   42 4200
> B %*% A
     [,1] [,2]
[1,]  201  403
[2,] 2010 4030

> x <- c(1,1)
> x %*% A
     [,1] [,2]
[1,]    3    7
> A %*% x
     [,1]
[1,]    4
[2,]    6
> x %*% A %*% x
     [,1]
[1,]   10
```

##### 행렬의 주대각선 요소와 대각행렬
행렬을 이용한 수학적 연산에서 행렬의 주대각선 요소나 대각행렬은 매우 중요한 역할을 수행한다. R은 diag() 함수를 이용하여 행렬에서 주대각선 요소를 추출하거나, 대각행렬을 만든다. diag() 함수는 첫번째 인수 x 에 어떤 형식의 데이터가 오는지에 따라 다른 연산을 수행한다.
```r
> A
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> diag(A)
[1] 1 4
> diag(1:4)
     [,1] [,2] [,3] [,4]
[1,]    1    0    0    0
[2,]    0    2    0    0
[3,]    0    0    3    0
[4,]    0    0    0    4
> diag(3)
     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    1    0
[3,]    0    0    1
> diag(3, nrow = 2)
     [,1] [,2]
[1,]    3    0
[2,]    0    3
```

##### 일차 연립 방적식과 역행렬
$$
\begin{aligned}
2x - 3y = 5 \\
-2x - 4y = -4 \\
Ax = b
\end{aligned}
$$
$$
A = \begin{bmatrix}
2 & -3 \\
-2 & 4
\end{bmatrix} , 
x = \begin{bmatrix}
x \\
y 
\end{bmatrix},
b = \begin{bmatrix}
5  \\
-4
\end{bmatrix}
$$
``` r
> A <- matrix(c(2, -2, -3, 4), nrow = 2, ncol = 2); A
     [,1] [,2]
[1,]    2   -3
[2,]   -2    4
> b <- c(5, -4); b
[1]  5 -4
> x <- solve(A, b); x
[1] 4 1
> A %*% x
     [,1]
[1,]    5
[2,]   -4
# solve() : 첫전째 인수 a에는 연립 일차 방정식의 좌변의 계수를 나타내는 정방행렬, 두번째 인수 b에는 우변의 상수항을 나타내는 벡터가 제공된다. 함수의 두번째 인수 b가 주어지지 않으면 b를 단위 행렬로 하여 해를 구한다.

```

##### 고유치와 고유벡터
행렬의 고유치와 고유벡터를 구하기 위해서는 eigen() 함수를 이용한다. eigen() 함수의 결과는 values와 vectors라는 이름을 가진 두 요소를 가지는 리스트이다.
```r
> A
     [,1] [,2]
[1,]    2   -3
[2,]   -2    4
> ev <- eigen(A); ev
eigen() decomposition
$values
[1] 5.6457513 0.3542487

$vectors
           [,1]       [,2]
[1,]  0.6354064 -0.8767397
[2,] -0.7721779 -0.4809652

> ev$values
[1] 5.6457513 0.3542487
> ev$vectors
           [,1]       [,2]
[1,]  0.6354064 -0.8767397
[2,] -0.7721779 -0.4809652

# 매우 큰 행렬의 경우 고유벡터가 필요하지 않다면 계산하지 않는 것이 효율적이다. 이때 eigen() 함수의 only.values = TRUE 로 설정하면 된다.
> eigen(A, only.values = TRUE)
$values
[1] 5.6457513 0.3542487

$vectors
NULL
```

